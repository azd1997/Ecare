# 关于角色设定

## 角色分级
`types.Role`结构体中角色级别或者说编号大于等于0.
整个系统节点网络呈现动态树状结构：源节点、转发节点、叶节点
`Role0`用来表示区块链系统的创建者，
`Role1~Role9`留以表示系统中的转发节点角色
转发节点同时拥有挖矿权力也就是记账的权力，出块的那个节点在那个时间段为源节点，其余则仍为转发节点
普通用户则为叶节点，不进行转发任务，多表示那些无法确保节点在线稳定性的节点。

在场景设定中，设定了`Hospital`、`Research`(third-party)、`doctor`、`patient`四类角色，
分别以H、R、D、P表示，显然，在这个场景中Role编号分别为1,2,10,11.

此外，为描述方便，称转发节点为A类节点、叶节点为B类结点

## 节点地址描述
通信基于tcp点对点通信，所以默认通信方式就是tcp，故节点通信地址的表示为：
`127.0.0.1:8001`的字符串，表征ip与监听端口号。

## A类节点维护的地址集合

- L1: 所有以A类账号登录的A类结点地址集合，进行可用检测后得到的可用节点集合（持久化到本地）
- L2: 向该转发节点发起连接请求的所有B类节点地址（内存中，退出即删除）

## B类节点维护的地址集合

- L1
- L3: 普通节点的朋友节点，由用户自己添加，添加后可与转发节点一起进行状态同步

## 多连接并发通信树

这里指转发节点（包括朋友节点）在进行数据转发时在不超过最大连接数时并发通信。

## 货币说明

每个转发节点根据初始投入资金发放账户初始余额，例如100万。

每个转发节点维护需要消耗资金，因此通过coinbase交易对其作补偿，
coinbase交易固定发放一定数额数字货币。

## 谁来挖矿

转发节点拥有挖矿权力。
为了避免无意义的挖矿竞争，加快交易速度，
最主要是为了加快病人相关交易的广播速度，
那么就要优先满足包含更多合法交易的区块，
在这个同步过程中，每个转发节点一旦交易池交易超过2个就开始挖矿，
这样的做法使得大家在竞争谁出块更快谁传播的更快更占优势。

这里应该抛弃工作量证明等证明策略，这浪费了所有转发节点的能力。

因为交易中含有病人处理心电信号的交易，这应该尽可能提高结果速度

- 策略1： 

病人产生交易的同步策略是优先转发给ping通速率最快的节点，
再向其他转发节点继续发送。

那么同一个时间段转发节点可能收到一批交易txs[i]，
不同转发节点的txs之间有不同的也可能有相同的，为了尽可能快的处理病人交易
那么需要尽可能快且全的收集该时间段所有交易

~~那么在一个时间段内谁最先收集到更多的交易就让谁出块，这个策略效率更高
那么怎么证明自己收集了更多的交易呢~~
每一个周期结束所有转发节点进行挖矿并广播，最先接收到的区块且包含交易最多的被接受。

这样能决出多数者，但是必然存在同一时间段内不同转发节点持有不同新区快。
这使得叶节点需要同步新区快时会出现叶节点获取到不同的新区块，这是个致命性的问题。

要想避免这种不一致，必须由某个节点主导，这样才能减少分区不一致的几率和风险。有两个改进的地方，
一个是在出块节点选取时就采用确定性选举策略（如策略2），
另一个是在确定谁拥有最多交易时由确定性策略选出一个节点用来统计。period1大家收集tx，period2大伙选出一个裁判，
裁判会在period2收集大家的交易数，得出最大值，告诉最大值给出了最大值的节点出块


- 策略2： 

（这里也可以采用一种选择方法选择一个节点让大家都向他同步，这种策略可以是按顺序轮流成为源节点，
源节点若失效）
为了尽可能减少无意义的p2p同步，采用可用节点间按序循环、离线跳过的策略。对于{A1,A2,...,Ai,...,An}可用转发节点集合，轮到Ai出块时称Ai值班
其他所有节点将收集的交易第一时间发给值班节点（发完之后当然还要继续在发给其他节点），这使得值班节点毫无疑问的成为收集tx最多最快的节点，出块顺理成章。
如果0.5个Period之后A(i+1)节点没收到新区快，则向其余节点询问看是不是有新区快，如果都没有，那么说明Ai节电出问题，A(i+1)出块。

为了保证病人的使用体验，每一次出块间隔设在30~60s，Period = 60s

## 通信协议

### 创建区块链
准备环境
H1,H2,H3,R1,R2  D1,D2,P1,P2,P3,P4,P5  Role0
A1,A2,A3,A4,A5  B1,B2,B3,B4,B5,B6,B7

1.Role0（A1）创建区块链，产生第一个区块，开启节点监听。
2.A2上线(L1预存A1)，先向向A1(L1第一个)请求区块数据（RequestBlocks），同步到本地，构建本地区块链.A1判断A2节点类型后将A2添加到L1中
3.A3上线，也是先向A1请求区块链数据，A1将A3加入L1，再向A3发送已存的L1信息，再去把区块链数据发给A3
4.发区块链数据的过程：A3直接向L1中所有节点（A1）请求blocks，A1节点先向A3发送L1，接着A1给A3发送version信息，告诉A3我的区块链长度；
A3同时接收L1，形成自己的L1，向L1的其他节点请求blocks。
5.A3收到A1的version信息后比较自身区块链长度，发现自身没有区块链，也就是长度为0，则向A1发送getinv请求，获取区块哈希，将其添加到blockInTransit，
再向A1发送getdata请求请求这个数组第一个区块哈希指向的区块数据，将收到的区块保存到数据库中，从数据库continueChain。此时由于区块链中只有创世区块，
所以只接收一次创世区块。

在这个过程中显然A3按照时间先后会先收到A1发来的区块数据而后再去请求A2的。为了避免资源浪费，应该先向A1请求完A1持有的A3没有的全部的的区块，如果一切顺利，
那么A3将拥有一份A1现阶段的区块备份，其向L1其他节点广播inv信息（对inv进行改进，增加区块ID信息（或者说区块高度、区块长度）），告诉其他节点我也有这些区块了。
~~再接着向L1下一个其他节点发送~~，紧接着向L1其他节点比如说A2请求区块，同样的A2也会发version过来，如果A2更长则向A2请求进一步的数据，如果A2更短，则向A2发送inv信息
A2就会向A3请求数据

那么如果A3向A1请求blocks的时候A1出现问题了：等待2s超时。那么就解析来请求下一个节点。

这样超时再请求的策略意味着想要获取到完全的区块链最新状态是比较慢的。与之相对应的另一种策略是同时向L1所有节点并发请求区块。

实际上情况是如果系统正常运行一段时间后有A类节点20个，一般来讲，请求3~5个节点应该就能得到最新状态了，全部都发请求有些太浪费了，建立了过多网络连接。

折中处理呢？同时请求三个？请求完再请求下三个？

另一个思路：当A3向A1拿完区块数据后，向所有节点广播自身inv信息。（想一想：这样子是不是增大了数据传输流量？因为需要附带很多区块哈希值），那么将version信息给修改掉,
附带一个区块哈希的哈希总值。例如version中区块链长度为5，附带的哈希值为5个区块哈希形成的切片的哈希。 并且在每个节点都维护一个哈希表记录每个节点的version信息，  
这样的话其他节点一看到这个version就知道你有5个区块，如果我比你长，我可以去检查下我的在长度为5及以前的区块，计算这个校验值，看是否相等，相等就直接告诉你后边的区块
不相等则告诉你我有6个区块，发送inv信息，包含每个区块的哈希，这样子你就可以看到从第几个开始你就不对了

发现自己比对方短并且这部分还和对方不一样，怎么确定谁是对的呢？分两步：

第一步是：因为我有其他节点的“最新”version信息，但是要注意的是，当我遇到这种情况时，我所收集的其他节点的最新version应该是和我自身等长的或更短的（思考一下就知道了）
那么我此时再向列表所有节点请求最新inv。


### 对方区块链比自己长，且过往一致

因为在这个设计中，只要是包含的交易是合法的，区块都应该视为合法的，而且在这个系统也不是谁先发就承认谁，而是在period内谁取得了交易量证明（POT），
请求这些区块，检查合法与否。

（每个节点在广播交易时统计每一次发送交易的耗时，根据这个耗时排序这个节点集合，并移除不可用节点）

这样做的结果是，最长链一定是当前出块节点，以及已经同步了最长链的节点。

所以正常的同步过程中发现对方比自己长都是只长一个区块，只要检查这个区块合法与否再添加进来就可以

### 对方比自己长，且过往不一致

请求inv存证全部，与本地比较，从不一致处开始向后接纳对方的。（最长链原则）前提是对方的是合法的。

这种情况下里边的交易怎么办？四类交易，普通转账交易可以直接回滚，其他三类交易呢？

事实是这个回滚只是该节点本地的回滚，尽管不影响整个系统，但会影响一般向该节点同步数据的普通节点，这怎么办？

1. 普通节点上线同步时向连接最快的三个节点同步，降低这个影响，三个节点同步的话多数者胜
2. 该节点在接纳更长者之前，检查本地维护的已存在的其他所有节点最新version信息。（这使得该节点以前的状态一定是和大家一样的，从另一方面也说明了该小节这种情况几乎不可能出现），
如果更长者过往不一致，比如自己当前是第5个，比较集合内第5个以前verion信息，多数者胜

### 转发节点重新上线后如何同步

因为运行中，转发节点会维护转发节点列表并持久化到本地，重新上线后，向转发节点列表顺次请求，并根据响应时间排序。

### POT交易量证明
1个period结束后大家开始寻求POT证明。

每个节点维护所有转发节点列表的话，想要获取到POT，只需要向其他节点请求交易量，看谁是拥有最大交易量的节点，如果是自己最大就自己出块，这个交易量集合
生存周期为period，每个节点维护的这个集合就是pot证明，用于接收这个周期产出的区块，不符合POT的将被丢弃

这个过程是一个群体比较的过程，要是有个中间人该比较会很快。中间人策略全网络只需要2×（n-1）次连接（其他节点发给中间节点，中间节点再发回），
而前面所述的过程需要2×n*（n-1）次连接（每个节点发给其他节点再接收返回）。

中间节点策略的耗时在于：选取中间人（可以通过在共同列表里随机选择来加速中间节点选择）、中间节点接收其他节点
（实际做法应该是比如说等待10s收集所有发来的交易量）的交易量再排序选出出块节点告诉给其他节点

互发选举策略的耗时在于：每个节点直接向其他节点发送自己的交易量，同时也处理其他人发给自己的，这个过程等待10s（比如说），然后比较收到的
10s内的所有交易量，看是不是自己，不是自己就不发区块，是则发。

第二种策略的优势在于：更公平；其实比中间节点能更快出块（思考一下，互发其实是并发的）

接下来还有三个问题：

1. 如果获取了POT的节点在后边挂掉了：（1）还没挖出区块；（2）挖出区块发给了至少一个其他节点。每个区块在收集10s后就表示有人要出块了，再等10s
如果没接收到新区块，就像向其他节点请求version如果都没有，则认为这个选中的节点失效了。当然可以按交易量顺推下去，但是这20s里也是有新交易的，
所以选择重新进行POT。

2. 如何保证每个节点都维护了一份相同的转发节点集合？
确实有可能有些节点还来不及同步到最新的转发节点列表，但只会有少部分，而且缺失的只有1两个。一方面是这种特殊情况下的节点可能会误以为自己能发区块，
另一方面是这种特殊节点会接收到自己没收到的交易量的节点制造的区块。要解决这个问题，增加一个验证过程：如果收到的区块中有效交易量高于自己所认为的最大交易量
就接收并检查交易，都没有问题的话就接收，并且不再等待自己以为的出块节点的出块；

3. 如何保证所有节点时间线同步
暂且认为所有节点都使用unix时间戳
前面讲的period怎么去维护呢？每个节点开始一个period的真实时间都不一定相同，因为前面讲period开始是接收到合法区块之后开始新period，
而区块传输需要时间。这样子的话大家收集交易等这类活动就不是同时开始的。但是仔细思考下：虽然不是同时开始的，但这些交易还是都会被打包出去。

但问题在于，假如a,b,c三个转发节点，a在6点钟获得POT，出块，并开启新的period。而b,c接收到新区快可能已经6点半，这里需要注意：6点钟之前大家比较交易量时是a领先的
但之后，b,c也是一直在继续收集交易的，而当接收到区块后又会把区块包含的交易给删去。所以总体来讲不会影响交易的打包与各节点的竞争，前提是
系统同步一个区块的总耗时不能超过period，因为一个period结束后就会重新竞争POT。那么在这整个系统里谁决定了period的开启？答案是POT竞争.
每一次POT竞争结束意味着新period(对于整个系统而言的period)，而对于其他节点却不是（好好理解）。每一个period的开始都由POT获胜者决定！！！

至此大致解决了区块创建与转发节点之间同步的问题。而普通节点的同步区块将从可用区块列表速率前三去同步，上线时去同步。并且每隔一个period都会请求同步一次

POT竞争如何放置节点恶意虚报自身有效交易数？？？？

节点列表中节点附加一项 honest，此项与节点对应的账户的 available 同步。
一旦发现有一次竞争到POT的节点发来的区块与之不符，其他节点将之标记为！honest。之后再也不接受其pot竞选。
这个节点地址和账户相当于封号了，再也不能参与竞选和验证

### 关于客户端节点地址和区块链账户

客户端启动时必须以某个账户启动，如果本地有账户文件则读取第一个账户以之登录，没有的话可以指定一个账户启动并将该账户保存下来， 如果没有账户文件也不指定一个账户的话，会新建一个并生成本地账户文件

因此，在前边所述的同步操作中都需要在最开始检查自己的账户角色等。

### 关于交易是否能够回滚

不允许，因为这不是纯粹的货币系统，还牵扯到了医疗服务等。那么怎么防止回滚呢？

假如说区块9，区块10已经产生，我想要回滚区块10，那么需要跟在区块9后挖新区块10-1. 这个新区快会不会被承认呢？

要想被承认，需要在POT竞争中获胜，这是可能做到的，而区块内交易被承认也是完全可能的。

如果这样的区块被发出去，会产生前面同步中遇到过往不一致（历史不一致）的问题，那么收到该区块的节点可以通过version集按照服从多数的策略来判断。

另外一点是，避免允许这种区块的可能：

在竞争POT时，信息还要添加上出块id或者说序号。出块ID小于等于本地区块链长度者不参与POT竞选，直接失去资格

POT { block_id, txnum }

### 关于恶意注册普通用户账号来支持自己的转发节点掌控出块权

这个区块联系统不是可以随便加入的，每一个账户注册时必须添加其身份信息（姓名，电话，邮箱，健康状况，医院）
这能够避免恶意注册多个账号。

那这个身份信息怎么添加和管理呢？
希望身份信息只被医院知悉，其他角色不能获知
初始角色必须是医院，然后普通用户想要注册时需要向网络中任意一个医院节点所运行的broker发布身份数据，方可创建账户。

但这个策略尚不完善。

### 关于二段交易中交易一段转账金额

设置一个临时金额池，用于存放待转金额。若二段接收则进行状态修改。

### 关于数据密码的一个想法

使用当前时间作为随机数的核生成随机密码，解码一次后自动重新加密一次，二段加密后连原持有人都不知道密码


### 关于账户、余额、角色的想法

之前的想法是所有节点都维护一个全局表，里边存了所有人的id/role/balance等属性。这样的好处是查余额、校验这些时候很方便直接查表就好了。
但是这涉及到这些属性的同步。只需要每个节点创建账户之后广而告之，那么大家都可以去更新本地的这个表。
这样的话每个账户已创建就必须向网络发布一个消息newaccount。所以创建账户的那一个api必须在**节点已启动时**或者**一创建完就以该账号启动**

这个做法还有一个非常致命的问题：账户表可以查余额，区块链也可以查余额，由于网络原因必然存在两者冲突的情况，就是两种方法查到的余额不相同。

另一种想法是不采用这种账户表的形式，而是通过区块链去获取余额等信息。这样做法可以是节点从区块链中得出状态变化，维护本地的余额表。
这样的做法好处是余额只有唯一途径确定，但是这样显然只能查到产生了交易的账户。不利于转账交易时的账户检验（这样做账户检验只能检验基本格式是否正确）。

折中一下，在第二种的基础上，增加一个账户表，账户表中余额信息必须通过区块链来更新，其他信息由创建时newaccount网络同步得到





















