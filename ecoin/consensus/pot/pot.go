package pot

// PoT PoT是收集交易数最多的节点出块。
// PoT依赖于 UBTXP（还没被打包的交易）、TBTXP（准备打包的交易） 两个交易集（交易也可以泛化为数据data，三个特殊的数据集）
// 每个节点在不断地监听所有节点（这里称他们为客户端）的交易（直白点说叫客户想要上传数据）
// 共识节点 NodeX 验证收到的交易合法后会放入到 UBTXP 。
// 1. 假设当前已出第n个区块，第n个区块的构建时间为 t_n， 当前时间为 t_now, 当当前时间等于 t_n + EP/2 (EP 是设定的正常情况下出块周期) 时，
// PoT Competition 开始。
// 2. 当PoT competetion开始时，所有共识节点统计 UBTXP以及TBTXP中的交易数num和交易总哈希校验码checksum，这两项合并为PotMsg
// 向其他节点发送自己的PotMsg. 注意当节点统计num时就要将所有的交易转移到TBTXP中，清空UBTXP。
// 当然节点也会开始收到其他共识节点发来的PotMsg，收集起来，比如用一个列表. 收集的截止时间是 t_n + EP
// 3. NodeX 发现自己的 num(第一比较项)和checksum（第二比较项）是列表中最大值，则他成为了出块者，也就是Winner，
// 然后他将TBTXP中的交易全部打包成新区块发布，此时系统的区块时间变成了 t_n+1 （或者说从oldtime变成newtime，
// 但是oldtime需要保留，因为这个新区快可能是无效的，需要将区块链时间回退到oldtime）.
// 同时他需要清空自己的TBTXP
// 4. 如果 NodeX 发现自己不是Winner， NodeY才是，那么它会等待EP/2时间（也就是直到 t_n + EP * 3/2）。
// 如果收到区块，检查区块是否是Winner的区块，不是则将该恶意节点删除出共识节点集，
// 如果发现了Winner的区块，检查没问题后加入本地区块链，并从TBTXP中剔除新区快已包含的交易
// 如果等到t_n + EP * 3/2都没有等到的话，就重新整理自己的交易，向其他节点发起PoT Competetion，重新竞争
// 5. 4中存在一种临界情况： Winner由于网络原因，新区块在t_n + EP * 3/2时传给了部分节点（M节点），而另一部分节点没有收到（N节点）。
// 这时N节点会开始发起POT竞争。注意POT需要等待 EP/2 时间。 而M 节点则已经接收了新区块，开始了新区块的准备工作，
// 他们正常的发起PoT竞争时间是在收到新区块构造时间的EP/2后，也就是说有可能M节点也已经发起了POT，也可能没有（但M节点之间的步调是一致的）
// 第一个困惑点是M、N都发起PoT。但一个是竞争新区块，一个是竞争旧区块
// 为了解决这个问题，PoT需要加上版本号version，竞争第n个区块的话PotMsg其version就是n。
// 那么当M节点收到了N节点的POTMsg时（版本号比自己低。即便有部分节点作恶故意虚报版本号也没用，匹配不上）
// M节点向N节点发送第 n+1 个区块信息，
// 因此所有使用PoT共识的区块链，在使用PoT时必须为
type PoT struct {

}
