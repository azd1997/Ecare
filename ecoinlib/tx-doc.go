package ecoin

// todo: 之后将response规范为结构体，便于审查

// todo: 新想法： 虽然病人的心电诊断类交易没法进行仲裁，但是可以考虑后面增加一个病人再返回的评论或者说反馈交易。

// TODO: 由于在新建交易的函数内之前采取了传递...interface{}而后再解析再检查的策略，使函数调用时显得比较难看，
//  考虑将这一版本注释掉，重新处理新建交易的传参。将参数封装为结构体！

// NOTICE: 为了保证Transaction的底层独立性，而且在new函数中作了一些基础的检验， 所以不提供verify方法
// （verify需要检查余额是否足够、签名是否有效，必然会和其他库文件耦合）。

// NOTICE: 暂定 医院H编号为1， 研究机构R编号为2， 医生D编号为10， 病人P编号为11

// NOTICE: TODO: 交易的验证：
// 交易检查的内容：
// a. 交易双方地址的有效性、角色的权限、转帐者的余额是否足够、转账者签名是否与其公钥匹配
// b. r2p、p2h、p2d需要检查目标数据是否在broker中
// c. p2r需要检查返回的数据使用凭证是否可用（这里考虑是否增加三段交易：用以做交易的反馈）
// 在这些检查项里边bc无疑是在验证节点（转发节点）本机就需要建立网络连接才能验证的，需要和broker连接才能进行验证。
// 这种网络操作是比较耗时的，应认为避免在验证阶段去做这个事情，而是交给交易双方自行判断。其他的验证则比较容易交给TX类本身来实现。
// 那么问题来了：交易双方如果发现对方发来的交易数据有问题，应该怎么做呢？（想象一下现实生活中淘宝购物的过程：用户下单 -> 商家发货 -> 用户发现商品有问题然后退货 -> 商家重新发货 -> ... ）
// 也就是说要将这个过程描述，需要两类交易。以病人和研究机构的交易过程来讲就是： r2p -> p2r -> r2p -> p2r -> ...
// 怎么表示交易完成而不互相扯皮呢？
// 交易发起方交易增加一个标志：txComplete（买家同意说交易确实完成了）。
// r2p（交易发起方）中若将之置为true，则其转账金额（临时扣除，记录在问“未完成交易池内”）退回；
// r2p complete : 交易发起方直接付钱给对方了，对方并不会返回结果给你
// r2p !complete -> p2r -> r2p complete : 交易发起方接收到对方的应答，认为是可以的，所以交易完成，金额支付给到对方
// r2p !complete -> p2r -> r2p !complete ?
// 这个过程天然是保护买家的权益的，买家若不满意只需要不停地！complete，交易就永远不会完成，钱不会到卖家那。当然钱也就卡在了“未完成交易池内”。
// 带来的问题：
// 1. 确实是卖家作恶给了假商品，但僵持下去买家的钱被卡住了。
// 2. 买家作恶，卖家收不到钱。
// 怎么解决？
// 问题1解决方法可以是：
// 僵持三次后如果买家仍然 ！complete 则出块节点检查区块中交易时进行仲裁，也就是返回结果的验证，
// 并以仲裁结果来更新全局状态机，而验证节点再进行验证。而且还可以据此判断哪一方信用出现问题，可以进行信用评分（暂时不实现，TODO）
// 这个解决办法怎么实现呢？(怎么知道已经僵持三次了)： 三种：一是每次检查这种交易时都去区块链历史中不断通过交易查找找到交易的前部交易。
// 这种做法需要从后往前遍历区块再遍历区块内交易，直到找到有一个r2p其内的p2r指针为nil（表示是这个交易总体的最开始）。然后得到就知道这个交易
// 是总体交易的第几个回合（一个回合指r2p -> p2r）。这个做法一个是遍历比较耗时（迭代而且是数据库操作），另一个是其他常规的正常的交易也要进行这种检查，
// 严重浪费。 二是在交易体内增加回合字段，标记到了哪个第几个回合。这个做法是比较可行的。 当然，检查交易时需要检查标记的回合是否是真的，而这种做法是检查不了的。
// 三是 交易体内不存放前一个交易指针（哈希值），
// 而是存前一个交易的[]byte，那么每次检查交易都把全部交易展开，这种做法对于性能的损伤不是很大，而且好处是不用去搜索区块链数据库就可以直到到了第几个回合。
// 等等，这种做法意味着要检查折叠的交易是否真的已经发布过，还是得遍历区块链数据库去匹配。但比做法一好一点，这种做法只需要检查最外层折叠交易是否存在即可。
// 总的来说，做法三是最合适的，因为这种做法在处理其他操作时也有很多好处。节省了很多遍历操作。
// 此外！这种情况下区块链向前遍历可以设置一个最大遍历数？ 因为在r2p的交易过程中r端是自动完成的（解析p发来的数据然后去自动尝试获取目标数据），所以也就是说
// 当发生这种三次僵持时，前一个交易（p2r）和当前交易（p2r）的间隔是遍历区间。由于这个时间段是用户处理的时间，是不确定的，有可能很长，也有可能很短，
// 这就意味着要遍历整个区块链！这种情况下是不能设置最大遍历数的。
// 等等！其实是可以精确定位到该交易的！
// 考虑 r2p{p2r} 。构造r2p时 p2r已经是被承认被出块了的也被r端轮询得到了，这样的话r端是完全可以知道p2r是在哪一个区块中发现的！！！
// 那么在r2p构造时额外提供一个字段：前部交易的所在区块号！那么检查交易时直接查这一个区块！没有说明交易不合法！
// 至此 问题1 得到了一个比较好的解决办法了
// 问题2呢？买家作恶，也就是r作恶，p收不到钱。
// 一样的，三次僵持自动仲裁。p2r侧交易体内加一个 txComplete(卖家认为应该是完成了)，同样的三次僵持之后，如果 p2r txComplete，表示卖家（p，病人）
// 认为自己是给的正确的，则自动仲裁 (这句看法是错的，p端可以不停地txComplete)
// 重新回到该问题：卖家正常发货，买家收到之后却不回复确认交易（也就是第二次r2p）甚至是不停的发r2p说卖家给假东西，卖家只能重新发，但买家继续僵持使卖家收不到钱。
//  r2p -> p2r -> r2p (买家是否认为交易完成) -> p2r -> ...
// 这里有两个子问题：（1）买家不回复r2p；（2）买家不断不断发起r2p(!complete)。这个自然而然的被上面问题一的解决方案解决了。
// 那么问题在于问题2(1)区块打包者和卖家一直没得到r2p（回复），卖家就没办法申诉仲裁，矿工也不知道有这个情况。
// 自然而然的，想到设置超时：比如卖家超过一天还是没找到这个回复则主动构建一个申诉交易（由于没有上个r2p）所以需要一个新的交易体。来告诉矿工去处理。
// 这是一个解决办法。只是这个超时时间存在两个问题：一是设多少合适？二是尽量希望能够保留很长时间，给一些出问题的节点一些机会；三是这个时间由卖家掌控了
// 留下了攻击隐患。
// 考虑一种新的办法： 转发节点维护“未完成交易池”，前面想到的交易池其实存的只是待转账记录，这里则把意义扩大了，
// 节点收到了这类交易（三类:r2p对、p2h对、p2d对），后检查其有没有问题后打包到区块，同时添加入“未完成交易池”，当接收到r2p三次僵持自动仲裁，
// 仲裁结果出来后，每一个验证节点若认为谁对，则把钱交给交易的哪一方。这个过程是没有重新构建交易的，是每个转发节点在本地做这个事情。
// 交易池内每个交易体新增一个定时器和通道，时间一到告诉调用线程有哪个悬而未决的交易需要处理。
// 这样做有个问题，这种事件的处理在每个节点上是各自进行的，所以进行的时间先后不一致。假设 A -> B 金额是5，A还剩10，假如说仲裁结果是A的钱应该退回
// 但由于验证节点做这个事情时间不一致，所以如果A要进行一笔消费为6（超过5）的交易，可能会在有些还没有进行仲裁的节点上被拒绝。
// 另外一个问题是当事人如何知道仲裁结果。
// 解决办法： 每个出块节点在出块时检查未完成交易池，看有没有超时交易或者三次僵持了的（称为”超时仲裁“和”三次僵持仲裁“），
// 这两种情况的交易出块节点将之进行仲裁，构建新的仲裁交易事件，这就保证了转发节点基本是同步得到仲裁结果的。
// 至于当事人如何知道，还是在同步区块链过程中查看交易内容发现与自己有关，再处理
//
// 其他两类心电诊断类交易则是没办法去验证卖家（医院或者医生）返回结果的有效性。最多只能对返回消息的格式做一个规定。
// 因此这种情况下，只要返回交易符合格式，就只能认为应该得到报酬，病人只能自动构建交易结束，验证节点们修改全局状态。
// 好了，这些问题都得到解决了。
//
// 有一个新的问题：如果是p2h、p2d交易p收到交易结果不回复怎么办？
// 对于这类交易不设complete字段，医院构建合法的回应段交易交易就生效了。
//
// 关于心电诊断交易，TODO： 以后修改成病人发起任务，可以由医院机器自动诊断 + 选取多位医生都进行诊断，这样的诊断结果对于病人是比较合适的。
//
// 另一个问题： 为什么我不直接设一个字段“是否申请仲裁”？避免被恶意攻击，如果有攻击者故意制造交易不断申请仲裁，这会拖慢区块产生速度，影响较大。
// 但是这样的三次僵持，一样还是会有这种可能性啊？？？
// 仲裁事件只出现在r与p之间这种可以由系统自动去“绝对判断”的交易情形，对于交易双方而言是发生在这个系统中的商业活动。
// 整个系统应该是以病人的需求为第一优先目标的，所以这种商业交易（包括以后增加的其他这种模式的交易）都应该尽量将耗时的验证交由交易双方自己去做。
// 所以“三次僵持”的目的不仅仅是为了解决自动处理交易矛盾，也是为了鼓励商业交易双方诚信交易，让交易双方自己承担不诚信交易浪费的时间和性能代价。
// 同时也提供给这类商业交易多次磋商的机会，
// 从这个角度来看，依然采取 三次僵持 。

// 综上，格式方面的校验由交易类本身实现，出块节点和验证节点在检查时调用即可。而交易的实质内容是不是正确由交易双方自行判断，对于商业性质交易采取三次僵持策略
// 对于病人心电诊断类交易采取回应即生效策略

// 综上，需要进行的修改是：
// TX接口增加verify方法，传入*gsm来验证一些基本的信息以及格式是否无误。
// TxR2P增加p2rBytes和txComplete属性
// gsm增加 未处理交易池 。目前存入其中的只会是txr2p、p2h、p2d类
// 增加 仲裁交易

// 在类型修改的基础上修改方法

// 1. 构建交易时本身就作了交易构造时的校验： 转出账户是否余额足够、接收账户地址格式是否正确（转账地址是否存在由区块打包时做检查）、转账内容是否有效
// 2. 构建区块时和接收区块时对区块内交易做检查：

// NOTICE: 交易二段是怎么实现的？节点在线期间会根据设置的查询周期（比如一个小时）去遍历这段时间新增的区块内交易有没有与自己相关的交易，
// 有就展示到应用界面，当用户回应了这个交易，则自动将该交易从展示列表移除。
// 假设提供一个轮询开关，如果用户关闭了在线轮询，或者是刚上线，这时怎么去控制迭代范围避免遍历整个区块链呢？增加一个记录点，标志每次轮询区间的最末尾区块的编号
// 这个问题就解决了

// 交易要检查：
// 1.转账者、接收者是否存在
// 2.转账金额非负为整
// 3.转账者余额是否足够

// 一笔交易由转账者构建，A当然可以创建这个交易，但这个问题在于怎么确保其他人无法创建以A的地址和签名的交易

// 注意：结构体转json只会转导出元素，开头小写的属性不会被转为json
